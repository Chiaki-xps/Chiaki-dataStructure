# 哈希表(hashTable)

## 1. 哈希表介绍和特性

+ 哈希表通常是基于**数组**进行实现的，但是相对于数组，它也很多的优势：
  + 它可以提供非常快速的插入-删除-查找操作
  + 无论多少数据,插入和删除值都接近常量的时间: 即O(1)的时间复杂度。实际上,只需要几个机器指令即可完成;
  + 哈希表的速度比树还要快,基本可以瞬间查找到想要的元素.
  + 哈希表相对于树来说编码(代码)要容易很多
+ 哈希表相对于数组的一些不足:
  + 哈希表中的数据是没有顺序的，所以不能以一种固定的方式(比如从小到大)来遍历其中的元素(没有特殊处理情况下)
  + 通常情况下,哈希表中的key是不允许重复的,不能放置相同的key,用于保存不同的元素

### 1. 哈希表到底是什么？

+ 它的结构是数组，但是神器的地方在于对数组的下标值的一种变换，这种变换我们可以使用哈希函数，通过哈希函数可以获取到HashCode。
  + 当我们有一组数据，存入哈希表中，通过哈希函数建立数据与索引的关系后，当查找数据的时候，由哈希函数求出索引再直接数组取值。
  + 数据库是一个应用程序。哈希表是一个数据结构。
+ 从上面不难发现，哈希表的建立，首要就是把数据和索引值建立联系，其次解决下标值重复的问题

+ 哈希值通常是一个数字或字符串，在计算机中是以二进制形式存储的。

### 2. 哈希表的一些概念

+ **哈希化**：将大数字转化成数组范围内下标的过程，我们就称之为哈希化。
+ **哈希函数**：通常我们会将单词转成大数字，大数字在进行哈希化的代码实现放在一个函数中，这个函数我们称为哈希函数。
+ **哈希表**：最终将数据插入到这个数组，对整个结构的封装，我妈就称之为一个哈希表。

### 3. 什么是冲突？

+ 不同的数据产生相同的下标值既是冲突。（冲突理论上必然存在）
+ 最常用到的有两种方式：**链地址法**和**开放地址法**

#### 1. 链地址法(拉链法)

+ 常用的方案
+ 从下面图片看出，链地址法解决冲突的办法是每个数组单元中存储的不再是单个数据，而是一个链条。
  + 这个链条可以是数组，链表，树等
  + 例如链表，每个数组单元中存储着一个链表。一旦发现重复，将重复的元素插入到链表的首端或末端即可。
  + 当查询时，先根据哈希化后的下标值找到对应的位置，再取出链表，依次查询找到数据。
+ 链条用数组还是链表呢？
  + 效率上差不多
  + 因为根据哈希化的index找出这个数组或者链表时，通常就会使用线性查找，这个时候两者效率差不多。

+ 链地址法是有缺点的，那就是如果一个链表或者数组的数据过多，查询效率就会下降，因为需要遍历链表或者数组。

![image-20230620144815642](哈希表.assets/image-20230620144815642.png)

![image-20230620144913841](哈希表.assets/image-20230620144913841.png)

+ 上图用的是链表

#### 2. 开放地址法

+ 用的不多了

+ 开放地址法的主要工作方式是寻找空白的单元格来添加重复的数据。

+ 探索这个位置的三个：

  + 线性探测：
    + 线性的查找空白的单元，挨个+1找到空白的位置就插入。

  ![image-20230620171630362](哈希表.assets/image-20230620171630362.png)

  ![image-20230620171741018](哈希表.assets/image-20230620171741018.png)

  + 二次探测

  ![image-20230620172138930](哈希表.assets/image-20230620172138930.png)

  + 再哈希法

  ![image-20230620172252914](哈希表.assets/image-20230620172252914.png)

### 4. 哈希效率





## 2. 数据的哈希化过程



## 3. 地址冲突解决方案



## 4. 哈希函数代码实现



## 5. 哈希表创建和操作



## 6. 哈希表的自动扩容

 