# 哈希表(hashTable)

## 1. 哈希表介绍和特性

+ 哈希表通常是基于**数组**进行实现的，但是相对于数组，它也很多的优势：
  + 它可以提供非常快速的插入-删除-查找操作
  + 无论多少数据,插入和删除值都接近常量的时间: 即O(1)的时间复杂度。实际上,只需要几个机器指令即可完成;
  + 哈希表的速度比树还要快,基本可以瞬间查找到想要的元素.
  + 哈希表相对于树来说编码(代码)要容易很多
+ 哈希表相对于数组的一些不足:
  + 哈希表中的数据是没有顺序的，所以不能以一种固定的方式(比如从小到大)来遍历其中的元素(没有特殊处理情况下)
  + 通常情况下,哈希表中的key是不允许重复的,不能放置相同的key,用于保存不同的元素

### 1. 哈希表到底是什么？

+ 它的结构是数组，但是神器的地方在于对数组的下标值的一种变换，这种变换我们可以使用哈希函数，通过哈希函数可以获取到HashCode。
  + 当我们有一组数据，存入哈希表中，通过哈希函数建立数据与索引的关系后，当查找数据的时候，由哈希函数求出索引再直接数组取值。
  + 数据库是一个应用程序。哈希表是一个数据结构。
+ 从上面不难发现，哈希表的建立，首要就是把数据和索引值建立联系，其次解决下标值重复的问题

+ 哈希值通常是一个数字或字符串，在计算机中是以二进制形式存储的。

### 2. 哈希表的一些概念

+ **哈希化**：将大数字转化成数组范围内下标的过程，我们就称之为哈希化。
+ **哈希函数**：通常我们会将单词转成大数字，大数字在进行哈希化的代码实现放在一个函数中，这个函数我们称为哈希函数。
+ **哈希表**：最终将数据插入到这个数组，对整个结构的封装，我妈就称之为一个哈希表。

### 3. 什么是冲突？

+ 不同的数据产生相同的下标值既是冲突。（冲突理论上必然存在）
+ 最常用到的有两种方式：**链地址法**和**开放地址法**

#### 1. 链地址法(拉链法)

+ 常用的方案
+ 从下面图片看出，链地址法解决冲突的办法是每个数组单元中存储的不再是单个数据，而是一个链条。
  + 这个链条可以是数组，链表，树等
  + 例如链表，每个数组单元中存储着一个链表。一旦发现重复，将重复的元素插入到链表的首端或末端即可。
  + 当查询时，先根据哈希化后的下标值找到对应的位置，再取出链表，依次查询找到数据。
+ 链条用数组还是链表呢？
  + 效率上差不多
  + 因为根据哈希化的index找出这个数组或者链表时，通常就会使用线性查找，这个时候两者效率差不多。

+ 链地址法是有缺点的，那就是如果一个链表或者数组的数据过多，查询效率就会下降，因为需要遍历链表或者数组。

![image-20230620144815642](哈希表.assets/image-20230620144815642.png)

![image-20230620144913841](哈希表.assets/image-20230620144913841.png)

+ 上图用的是链表

#### 2. 开放地址法

+ 用的不多了

+ 开放地址法的主要工作方式是寻找空白的单元格来添加重复的数据。

+ 探索这个位置的三个：

  + 线性探测：
    + 线性的查找空白的单元，挨个+1找到空白的位置就插入。

  ![image-20230620171630362](哈希表.assets/image-20230620171630362.png)

  ![image-20230620171741018](哈希表.assets/image-20230620171741018.png)

  + 二次探测

  ![image-20230620172138930](哈希表.assets/image-20230620172138930.png)

  + 再哈希法

  ![image-20230620172252914](哈希表.assets/image-20230620172252914.png)

### 4. 哈希化效率

+ 哈希表中执行插入和搜索操作效率是非常高的 
  +  如果没有产生冲突，那么效率就会更高
  + 如果发生冲突，存取时间就依赖后来的探测长度。
  + 平均探测长度以及平均存取时间，取决于装填因子，随着装填因子变大，探测长度也越来越长。

  + 装填因子

    + 装填因子表示当前哈希表中已经包含的数据项和整个哈希表长度的比值。

    + 计算公式: 装填因子 = 总数据项 / 哈希表长度
    + 开放地址法的装填因子最大是多少呢？**1**，因为它必须寻找到空白的单元才能将元素放入。
    + 链地址法的装填因子呢?**可以大于1**，因为拉链法可以无限的延伸下去，只要你愿意。(当然后面效率就变低了）

  + 哈希表的查找效率与装填因子的大小是负相关的
    + 装填因子越大，查找效率越低
    + 所以当装填因子达到一个值时，我们就要对哈希表进行扩容以保证效率
    + 链地址法受填装因子的影响较小，大多数语言也采用此方法，所以我们就实现链地址法。

### 5. 了解一下

![image-20230621173001722](哈希表.assets/image-20230621173001722.png)

![image-20230621173459445](哈希表.assets/image-20230621173459445.png)

![image-20230621173918214](哈希表.assets/image-20230621173918214.png)







## 2. 数据的哈希化过程



## 3. 地址冲突解决方案



## 4. 哈希函数代码实现



## 5. 哈希表创建和操作



## 6. 哈希表的自动扩容

 