# 排序算法（Sorting algorithm）

+ V8用的就是归并排序和快速排序

+ JS底层大多用的是归并和快排

![image-20230719121634529](排序算法.assets/image-20230719121634529.png)

## 1. 冒泡排序（Bubble Sort）

![image-20230720174404660](排序算法.assets/image-20230720174404660.png)

+ 时间复杂度：

  + 理想状态下。数组长度为n，只需要遍历一次，发现没有发生交换，说明已经排序好了，直接返回。那么循环实际执行了n-1次，那么时间复杂度推导为O(n)。交换的次数0次，交换操作时间复杂度为O(0)。

  + 最坏的情况，就是数组长度为n，里面的数据都是逆序的。需要进行n-1轮排序，每一轮中需要进行n-i-1次比较和交换操作。即 n^2^ - 2n + 1即O（n^2^）。

    交换次数O(n^2^)

  + 平均情况O(n^2^): 数据都是随机顺序的情况下，每一对元素的比较和交换都有1/2的概率打死，需要进行n-1轮排序，每一轮中需要进行n-i-1次比较和操作。

+ 冒泡排序的时间复杂度主要取决于数据的初始顺序。最坏的情况下，时间复杂度O(n^2^)，不适用于大规模数据的排序。

## 2. 选择排序（Selection Sort）

+ 选择排序（Selection Sort）是一种简单的排序算法。
+ 基本思想：
  + 首先在未排序的数列中找到最小（大）元素，然后将其存放到数列的起始位置。
  + 接着，再从剩余未排序的元素中继续寻找最小（大）元素，然后放到已排序序列的末尾
  + 以此类推，直到所有元素均排序完毕。
+ 选择排序中，比较次数仍然是n-1次，但是交换次数为1次。相对于冒泡排序上，优化了交换次数。
+ 时间复杂度：
  + 最好情况：数组本身是有序的，那么内循环每次都需要执行n-1-i次，因此比较次数n(n-1)/2，交换次数为0。所以时间复杂度为O(n^2^)。
  + 最坏情况: 数组是排序数组的倒序排序，内层循环都需要比较n-1-i次，因此比较次数为n(n-1)/2,交换次数也为n(n-1)/2。所以排序的时间复杂度为O(n^2^)
  + 平均情况时间复杂度：O(n^2^)

+ 时间复杂度的结论没错，但是分析有点问题，后面改。

## 3. 插入排序（Insertion Sort）

+ 从小到大排序：一个数组中，我们假设第一个数据已经排序好（或者已经排序好的数据），后面的数据开始进行与向前进行比较，然后找到比他小的数的位置，然后后面的位置向后移动一个单位，数据插入到空出来的位置上。

+ 复杂度分析：
  + 最好的情况O(n): 如果数据已经排序好，那么每个元素只需要比较一次就可以确定位置，因此比较次数为n-1。移动次数为0。
  + 最坏的情况O(n^2^): 如果数据是倒序的，那么比较次数为n(n-1)/2,移动次数也为n(n-1)/2。那么插入倒序的时间复杂度为O(n^2^)
  + 平均情况就是O(n^2^)
+ 如果数组部分有序，插入排序可以比冒泡排序和选择排序更快。
  + 但是数组完全逆序，则插入排序的时间复杂度比较高，不如快速排序或归并排序。

![image-20230724143402566](排序算法.assets/image-20230724143402566.png)

+ 缺点：假如有一个数据特别大，且位置靠前，那么每次比较的时候，这个数据都要不断向后移动，比较浪费性能，反之，一个特别小的数据靠后，那么需要不断比较向前移动。
+ 优点：针对数据大部分已经排序好的数据来说，性能上比较优秀

![image-20230724143901864](排序算法.assets/image-20230724143901864.png)

## 4. 归并排序（merge sort）

+ V8引擎中就用到了归并排序。

+ 归并排序（merge sort）：
  + 它的基本思想是将待排序的数组分成若干个子数组。
  + 然后将想了的子数组归并成一个有序数组
  + 最后再将这些有序数组归并（merge）成一个整体有序的数组

+ 归并排序的基本思想是先将待排序数组递归地拆分成两个子数组，然后对每个子数组进行排序，最后将两个有序子数组合并成一个有序数组。

+ 归并排序的时间复杂度O(n log n)

+ 思路：

  1. 分解（Divide）: 归并排序使用递归算法来实现分解过程。（一层一层对半分两个数组，然后一层层合并返回）
     + 如果待排序数组长度为1，认为这个数组已经有序，直接返回。
     + 将待排序数组分成两个长度相等的子数组，分别对这两个子数组进行递归排序；
     + 将两个排序好的子数组合并成一个有序数组，返回这个有序数组。

  2. 合并（Merge）: 合并过程中，需要比较每个子数组的元素并将它们有序地合并成一个新数组：
     + 可以使用两个指针i和j分别指向两个子数组的开头，比较它们元素的大小，并将小的元素插入到新的有序数组中
     + 如果其中一个子数组已经遍历完，就将另一个子数组的剩余部分直接插入到新的有序数组中。
     + 最后返回这个有序数组
  3. 归并排序的递归终止条件：
     + 归并排序使用递归算法来实现分解过程，当子数组的长度为1时，认为这个子数组已经有序，递归结束。（递归到最后，数组长度为1就不需要继续分解，排序也一定是有序的）

+ 总体来看，归并排序的基本思路是分治法，分成子问题分别解决，然后将子问题的解合并成整体的解。

+ 分解的次数为log n 次。

+ 复杂度分析：

  + 假设数组长度n，需要进行log n次归并操作（指的是分解和合并）：分解 log n次吗，合并log n次，所以时间复杂度O(log n)
  + 每次归并操作需要O(n)的时间复杂度：每一次循环中，都需要把里面每个数字扫描一遍，传入到新数组里，所以时间复杂度为O(n)
  + 因此归并排序的时间复杂度为O(log n): 需要O(log n)次，每次O(n), 计算O(log n) * O(n),结果为O(log n)

  + 最好的情况O(log n):
    + 待排序数组已经是有序的，每个子数组都只需要合并一次，即一次归并操作（扫描忽略）
    + 因此时间复杂度是O(log n)
  + 最坏的情况O(n log n)
    + 最坏情况下，待排序数组是逆序的，那么每个子数组都需要进行多次合并。
    + 因此，此时的时间复杂度为O(n log n)
  + 平均情况O(n log n)
    + 在平均情况下，我们假设待排序数组中任意两个元素都是等概率出现的

## 5. 快速排序(QuickSort)

+ 快速排序（Quicksort）是一种经典的排序算法，有时也被称之为：划分交换排序（partition-exchange sort）
+ 综合表现最好，可以进行原地排序，不需要开辟新数组。
+ 快速排序是基于分治思想的排序算法:
  + 基本思想是将一个大数组分成两个小数组，然后递归地对两个小数组进行排序
  + 具体事项方式是通过选择一个基准元素(pivot)，将数组分成左右两部分，左部分的元素都小于或等于基准元素，右部分的元素都大于基准元素。
  + 然后，对左右两部分分别进行递归调用快速排序，最终将整个数组排序。

+ 快速排序是一种原地排序算法，不需要额外的数组空间
  + 同时，快速排序的时间复杂度是O(n log n),在最坏的情况下是O（n^2^）。
  + 但是这种情况出现的概率非常小，因此快速排序通常被认为是一种非常高效的排序算法。 

![image-20230726141922694](排序算法.assets/image-20230726141922694.png)

+ 快速排序的思路：
  1. 首先，我们需要选择一个基准元素，通常选择第一个或最后一个元素作为基准元素。
  2. 然后定义两个指针i和j，分别指向数组的左右两端。
  3. 接下来，我们从右侧开始，向左移动j指针，直到找到一个小于或等于基准元素的值。
  4. 然后，我们从左侧开始，向右移动i指针，直到找到一个大于或等于基准元素的值。
  5. 如果i指针小于等于j指针，交换i和j指针所指向的元素。
  6. 重复步骤3-5，知道i指针大于j指针，这时，我们将基准元素与j指针所指向元素交换位置，将基准元素放到中间位置。
  7. 接着，我们将数组分两部分，左侧部分包含小于或等于基准元素的元素，右侧部分包含大于基准元素的元素
  8. 然后，对左右两部分分别进行递归调用快速排序，直到左右两部分只剩一个元素
  9. 最终，整个数组就变得有序了。

+ 复杂度分析：
  + 快速排序的时间复杂度主要取决于基准元素的选择、数组的划分、递归深度等因素
  + 最好的情况O(n logn)：
    + 当每次划分后，两部分的大小都相等，即基准元素恰好位于数组的中间位置，此时递归地深度为O(log n)
    + 每一层需要进行n次比较（每个数都要和基准比较）
    + 因此最好的情况下时间的复杂度为O(n log n)
  + 最坏情况 O(n^2^)
    + 当每次划分后，其中一部分为空，即基准元素是数组中的最大值或最小值，此时递归地深度为O(n)。例如数组本身就是有序的，那么分割数组的时候，会最终分成n份。
    + 每一层需要进行n次比较，因此最坏的情况下的时间复杂度为O(n^2^)
    + 需要注意的是，才用三数取中法或随机选择基准元素可以有效避免最坏情况的发生。
      + 三数取中法则，三个数中取中间数为pivot。
  + 平均情况O(n log n)：
    + 在平均情况下，每次划分后，两部分的大小大致相等，此时递归的深度为O(log n)
    + 每一层需要进行大约n次比较，因此平均情况下的时间复杂度为O(n log n)

+ 需要注意的是，快速排序是一种原地排序算法，不需要额外的数组空间。
+ 快速排序对比归并排序，少了合并的操作，所以实际上速度回更快。

## 6. 堆排序(Heap Sort)

+ 堆排序是一种基于比较的排序算法，它的核心思想是使用二叉树堆来维护一个有序序列。
  + 二叉堆是一种完全二叉树，其中每个节点都满足父节点比子节点大（或小）的条件
  + 在堆排序中，我们使用最大堆来进行排序，也就是保证每个节点都比它的子节点大。







 



































## x. 图包

![image-20230719120105436](排序算法.assets/image-20230719120105436.png)

![image-20230719121634529](排序算法.assets/image-20230719121634529.png)

![image-20230719180941446](排序算法.assets/image-20230719180941446.png)

![image-20230721114823183](排序算法.assets/image-20230721114823183.png)

![image-20230720174404660](排序算法.assets/image-20230720174404660.png)

![image-20230721120530461](排序算法.assets/image-20230721120530461.png)

![image-20230721121702207](排序算法.assets/image-20230721121702207.png)

![image-20230721143007049](排序算法.assets/image-20230721143007049.png)

![image-20230721143330348](排序算法.assets/image-20230721143330348.png)

![image-20230721143350727](排序算法.assets/image-20230721143350727.png)

![image-20230721145811547](排序算法.assets/image-20230721145811547.png)

![image-20230721150817500](排序算法.assets/image-20230721150817500.png)

![image-20230721151733256](排序算法.assets/image-20230721151733256.png)

![image-20230721154327669](排序算法.assets/image-20230721154327669.png)

![image-20230721154418374](排序算法.assets/image-20230721154418374.png)

![image-20230724143402566](排序算法.assets/image-20230724143402566.png)

![image-20230724153304725](排序算法.assets/image-20230724153304725.png)

![image-20230724153839021](排序算法.assets/image-20230724153839021.png)

![image-20230724160823749](排序算法.assets/image-20230724160823749.png)

![image-20230724161247420](排序算法.assets/image-20230724161247420.png)

![image-20230724230924308](排序算法.assets/image-20230724230924308.png)

![image-20230724234704427](排序算法.assets/image-20230724234704427.png)

![image-20230724235710300](排序算法.assets/image-20230724235710300.png)

![image-20230719115954027](排序算法.assets/image-20230719115954027.png)

![image-20230726141947569](排序算法.assets/image-20230726141947569.png)

![image-20230726141922694](排序算法.assets/image-20230726141922694.png)

![image-20230726183209994](排序算法.assets/image-20230726183209994.png)

![image-20230728164648601](排序算法.assets/image-20230728164648601.png)

![image-20230728164836409](排序算法.assets/image-20230728164836409.png)













 